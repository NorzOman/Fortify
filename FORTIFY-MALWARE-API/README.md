
# Backend & Malware Analysis Engine - Tasks (Oman)

## Objective

Your role is to build the core backend infrastructure that powers the entire mobile security application. This involves three major components:
1.  A **C++ Static Analysis Engine** to decompile and scan APK files for threats.
2.  A **Central API Server** that integrates the C++ engine and Raahim's phishing model.
3.  The **Implementation of specific API endpoints** for the mobile app (Arshad's task) to connect to.

---

## Part 1: C++ Static Analysis Engine

**Goal:** Create a command-line C++ application that can analyze an Android APK file and output a structured report of suspicious findings.

### 1.1. APK Decompilation & Extraction
-   **Task:** Your C++ program must be able to unpack an APK file to access its contents.
-   **Recommendation:** Do **not** build a decompiler from scratch. Instead, have your C++ program call a standard, reliable command-line tool like **`apktool`**.
    -   Your C++ code will execute a command like: `system("apktool d -f your_apk_file.apk -o output_directory");`
    -   This will decompile the APK into a human-readable format (Smali code, `AndroidManifest.xml`, resource files).

### 1.2. Regex-Based Scanning
-   **Task:** Once the APK is decompiled, your C++ program must read and scan key files using regular expressions (regex) to find malware indicators.
-   **Files to Scan:**
    -   `AndroidManifest.xml`: Scan for dangerous permissions (e.g., `<uses-permission android:name="android.permission.SEND_SMS"/>`).
    -   `smali` files (inside the output directory): Scan for suspicious API calls (e.g., `Landroid/telephony/SmsManager;->sendTextMessage`), reflection usage (`Ljava/lang/reflect`), or dynamic code loading (`LDalvik/system/DexClassLoader`).
    -   Any files containing code: Scan for hardcoded IP addresses or suspicious URLs.

### 1.3. Output
-   **Task:** The C++ program should output its findings in a structured **JSON format** to the console (stdout). This allows the server to easily parse the results.
-   **Example JSON Output:**
    ```json
    {
      "permissions": [
        "android.permission.SEND_SMS",
        "android.permission.READ_CONTACTS"
      ],
      "suspicious_apis": [
        "SmsManager->sendTextMessage",
        "DexClassLoader"
      ],
      "found_ips": [
        "198.51.100.5"
      ],
      "report_summary": "High risk detected due to SMS permissions and C2-like IP address."
    }
    ```

---

## Part 2: Unified Backend API Server

**Goal:** Create a central server that handles requests from the mobile app and orchestrates the analysis using the components from you and Raahim.

### 2.1. Server Setup
-   **Task:** Set up a web server using a framework you are comfortable with. **Python with Flask or FastAPI is highly recommended** as it will be easy to integrate Raahim's Python-based ML model.

### 2.2. Integration of Analysis Modules
-   **Phishing Detection (Raahim's Module):**
    -   Create an internal function or class that loads and runs Raahim's phishing detection script/model.
    -   Your API will pass incoming messages to this module to get a prediction.
-   **Malware Detection (Your C++ Engine):**
    -   Your server will receive an APK file upload.
    -   It will save the APK to a temporary location.
    -   It will then execute your C++ analysis engine as a **subprocess**, passing it the path to the saved APK.
    -   The server must capture the JSON output from the C++ program's console for further processing.

---

## Part 3: Mobile App Integration & Endpoint Implementation

**Goal:** Build the specific API endpoints that Arshad's mobile app will communicate with, following the required asynchronous workflow.

### 3.1. Asynchronous APK Scanning Workflow
-   **Endpoint: `POST /scanApk`**
    -   Accepts a file upload (`.apk`).
    -   Validates the `Authorization: Bearer <JWT>` header.
    -   Generates a unique `jobId`.
    -   Stores the job in a simple database (like SQLite or Redis) with a status of `"pending"`.
    -   **Immediately** returns the `jobId` to the mobile app: `{ "jobId": "some-unique-id-123" }`.
    -   **In the background**, trigger your C++ engine to analyze the APK. Once the analysis is complete, update the job's status to `"done"` in the database and store the JSON result.

-   **Endpoint: `GET /scanStatus?jobId=<jobId>`**
    -   Accepts a `jobId` as a query parameter.
    -   Looks up the job in the database.
    -   Returns the current status and result.
        -   If pending: `{ "status": "pending", "result": null }`
        -   If complete: `{ "status": "done", "result": { ... C++ engine's JSON output ... } }`

### 3.2. Asynchronous Message Scanning Workflow
-   **Endpoint: `POST /scanMessage`**
    -   Accepts a JSON body with the message and metadata.
    -   Follows the **same asynchronous pattern** as the APK scan: generate a `jobId`, store it, return it immediately, and process the message with Raahim's model in the background.

-   **Endpoint: `GET /scanMessageStatus?jobId=<jobId>`**
    -   Functions identically to `/scanStatus`, but for message scan jobs. It returns the status and, when done, the result from the phishing model.

### 3.3. General Requirements
-   **JWT Authorization:** All endpoints must be protected and require a valid `Authorization: Bearer <JWT>` header. For now, you can implement a simple validation placeholder.
-   **Configuration:** The server URL should be configurable, as required by the mobile app.