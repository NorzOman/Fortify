import argparse
import os
import shutil
import subprocess
import json
import re
import sys
from colorama import Fore, Style, init

init()

SANDBOX_DIR = "sandbox"
SOURCES_DIR = os.path.join(SANDBOX_DIR, "sources")
RESOURCES_DIR = os.path.join(SANDBOX_DIR, "resources")

SCAN_EXTENSIONS = ('.java', '.xml', '.smali')

EXCLUDE_PATH_COMPONENTS = {
    os.path.join('android'),
    os.path.join('androidx'),
    os.path.join('kotlin'),
    os.path.join('java'),
    os.path.join('javax'),
    os.path.join('org', 'json'),
    os.path.join('org', 'xmlpull'),
    os.path.join('junit'),
    os.path.join('android', 'support'),
    os.path.join('com', 'android', 'support'),
    os.path.join('com', 'google', 'android'),
    os.path.join('com', 'google', 'firebase'),
    os.path.join('com', 'google', 'ads'),
    os.path.join('com', 'google', 'gson'),
    os.path.join('com', 'google', 'zxing'),
    os.path.join('com', 'google', 'unity'),
    os.path.join('org', 'apache'),
    os.path.join('com', 'squareup'),
    os.path.join('com', 'bumptech'),
    os.path.join('com', 'facebook'),
    os.path.join('com', 'adjust'),
    os.path.join('com', 'appsflyer'),
    os.path.join('com', 'braze'),
    os.path.join('com', 'segment'),
    os.path.join('com', 'urbanairship'),
    os.path.join('com', 'onesignal'),
    os.path.join('com', 'razorpay'),
    os.path.join('com', 'stripe'),
    os.path.join('com', 'twilio'),
    os.path.join('io', 'branch', 'referral'),
    os.path.join('io', 'sentry'),
    os.path.join('io', 'reactivex'),
    os.path.join('com', 'fasterxml'),
    os.path.join('com', 'jakewharton'),
    os.path.join('com', 'crashlytics'),
    os.path.join('com', 'flurry'),
    os.path.join('com', 'mixpanel'),
    os.path.join('com', 'unity3d'),
    os.path.join('sandbox', 'resources', 'res', 'layout'),
    os.path.join('sandbox', 'resources', 'res', 'drawable'),
    os.path.join('sandbox', 'resources', 'res', 'anim'),
    os.path.join('sandbox', 'resources', 'res', 'menu'),
    os.path.join('sandbox', 'resources', 'res', 'xml'),
    os.path.join('sandbox', 'resources', 'res', 'raw'),
    os.path.join('sandbox', 'resources', 'res', 'color'),
    os.path.join('sandbox', 'resources', 'res', 'dimen'),
    os.path.join('sandbox', 'resources', 'res', 'font'),
    os.path.join('sandbox', 'resources', 'res', 'mipmap'),
    os.path.join('sandbox', 'resources', 'res', 'interpolator'),
    os.path.join('sandbox', 'resources', 'res', 'transition'),
}

patterns = []

def print_log(message, level="info"):
    if level == "info" or level == "debug":
        print(f"{Fore.CYAN}[ malware-scanner (-)] {message}{Style.RESET_ALL}")
    elif level == "success":
        print(f"{Fore.GREEN}[ malware-scanner (âœ”)] {message}{Style.RESET_ALL}")
    elif level == "warning":
        print(f"{Fore.YELLOW}[ malware-scanner (?)] {message}{Style.RESET_ALL}")
    elif level == "error":
        print(f"{Fore.RED}[ malware-scanner (!)] {message}{Style.RESET_ALL}")
    sys.stdout.flush()

def run_command(command, show_output=False, check_exit_code=True):
    try:
        process = subprocess.run(
            command,
            capture_output=True,
            text=True,
            check=check_exit_code,
            shell=True if isinstance(command, str) else False
        )
        if show_output:
            if process.stdout:
                for line in process.stdout.splitlines():
                    print_log(line, level="debug")
            if process.stderr:
                for line in process.stderr.splitlines():
                    print_log(line, level="error")
        return process.stdout.strip()
    except subprocess.CalledProcessError as e:
        print_log(f"Command '{e.cmd}' failed with exit code {e.returncode}.", level="error")
        print_log(f"Stdout: {e.stdout}", level="error")
        print_log(f"Stderr: {e.stderr}", level="error")
        sys.exit(1)
    except FileNotFoundError:
        print_log(f"Command not found: {' '.join(command) if isinstance(command, list) else command}", level="error")
        sys.exit(1)
    except Exception as e:
        print_log(f"An unexpected error occurred: {e}", level="error")
        sys.exit(1)

def check_jadx(jadx_path_arg):
    print_log("Checking JADX availability...", level="info")

    if os.path.isabs(jadx_path_arg):
        if os.path.exists(jadx_path_arg):
            if os.access(jadx_path_arg, os.X_OK) or sys.platform == 'win32':
                print_log(f"JADX found at provided absolute path: {jadx_path_arg}", level="success")
                return jadx_path_arg
            else:
                print_log(f"Provided JADX path '{jadx_path_arg}' is not executable. Please check permissions.", level="error")
                sys.exit(1)
        else:
            print_log(f"Provided JADX path '{jadx_path_arg}' does not exist.", level="error")
            sys.exit(1)
    else:
        print_log(f"JADX path '{jadx_path_arg}' must be an absolute path. Please specify the full path.", level="error")
        sys.exit(1)

def setup_decompilation(apk_path, jadx_exec_path):
    print_log("Decompilation started.", level="info")
    
    if not os.path.exists(apk_path):
        print_log(f"The APK file '{apk_path}' does not exist.", level="error")
        sys.exit(1)

    if os.path.exists(SANDBOX_DIR):
        try:
            shutil.rmtree(SANDBOX_DIR)
            print_log("Previous sandbox removed for fresh decompilation.", level="debug")
        except OSError as e:
            print_log(f"Error removing previous sandbox directory '{SANDBOX_DIR}': {e}", level="error")
            sys.exit(1)

    try:
        os.makedirs(SANDBOX_DIR)
        print_log("Sandbox directory prepared.", level="debug")
    except OSError as e:
        print_log(f"Error creating sandbox directory '{SANDBOX_DIR}': {e}", level="error")
        sys.exit(1)

    decompile_command = [jadx_exec_path, "-d", SANDBOX_DIR, apk_path]
    print_log(f"Executing JADX: {' '.join(decompile_command)}", level="debug")
    print_log("This process might take a while...", level="info")

    run_command(decompile_command, show_output=True)
    print_log("Decompilation completed.", level="success")

def get_files_to_scan():
    print_log("Collecting files to scan...", level="info")
    files_to_scan = []
    scan_dirs = [SOURCES_DIR, RESOURCES_DIR]

    for base_scan_dir in scan_dirs:
        if not os.path.exists(base_scan_dir):
            print_log(f"Scan directory '{base_scan_dir}' not found. Skipping.", level="warning")
            continue

        for root, dirs, files in os.walk(base_scan_dir, topdown=True):
            dirs_to_prune = []
            for d in list(dirs):
                relative_path_to_check = os.path.relpath(os.path.join(root, d), SANDBOX_DIR)
                normalized_relative_path = relative_path_to_check.replace(os.sep, '/')
                
                if any(exclude_path_comp.replace(os.sep, '/') in normalized_relative_path for exclude_path_comp in EXCLUDE_PATH_COMPONENTS):
                    dirs_to_prune.append(d)
            for d_to_prune in dirs_to_prune:
                dirs.remove(d_to_prune)

            for file in files:
                if file.lower().endswith(SCAN_EXTENSIONS):
                    filepath = os.path.join(root, file)
                    relative_file_path = os.path.relpath(filepath, SANDBOX_DIR)
                    normalized_relative_file_path = relative_file_path.replace(os.sep, '/')
                    
                    if any(exclude_path_comp.replace(os.sep, '/') in normalized_relative_file_path for exclude_path_comp in EXCLUDE_PATH_COMPONENTS):
                        continue
                    files_to_scan.append(filepath)
    
    if not files_to_scan:
        print_log("No relevant files found to scan.", level="warning")
    else:
        print_log(f"Collected {len(files_to_scan)} files.", level="info")
    return files_to_scan

def load_patterns(pattern_file="patterns.txt"):
    print_log(f"Loading patterns from '{pattern_file}'...", level="info")
    if not os.path.exists(pattern_file):
        print_log(f"Pattern file '{pattern_file}' not found. Please ensure it's in the same directory as main.py.", level="error")
        sys.exit(1)

    loaded_patterns = []
    with open(pattern_file, 'r', encoding='utf-8', errors='ignore') as f:
        for line_num, line in enumerate(f, 1):
            line = line.strip()
            if not line or line.startswith('#') or line.startswith('='):
                continue

            parts = line.split('::', 1)
            if len(parts) == 2:
                regex_str = parts[0].strip()
                label = parts[1].strip()
                try:
                    compiled_regex = re.compile(regex_str)
                    loaded_patterns.append((compiled_regex, label))
                except re.error as e:
                    print_log(f"Invalid regex on line {line_num} in '{pattern_file}': '{regex_str}' ({e}). Skipping.", level="warning")
            else:
                print_log(f"Malformed pattern on line {line_num} in '{pattern_file}'. Expected 'regex::label'. Skipping.", level="warning")
    
    if not loaded_patterns:
        print_log("No valid patterns loaded. Scanning will not find anything.", level="error")
        sys.exit(1)
    else:
        print_log(f"Loaded {len(loaded_patterns)} patterns.", level="info")
    return loaded_patterns

def scan_files(files_to_scan, output_json_path, patterns):
    print_log("Scanning started.", level="info")
    
    detections = []
    total_detection_count = 0
    total_lines_scanned = 0
    total_files_scanned = 0

    for filepath in files_to_scan:
        total_files_scanned += 1
        try:
            with open(filepath, 'r', encoding='utf-8', errors='ignore') as infile:
                for line_num, line in enumerate(infile, 1):
                    total_lines_scanned += 1
                    for compiled_regex, label in patterns:
                        if compiled_regex.search(line):
                            total_detection_count += 1
                            detection = {
                                "file": filepath,
                                "line": line_num,
                                "label": label,
                                "match": line.strip()
                            }
                            detections.append(detection)
        except FileNotFoundError:
            print_log(f"File not found during scan: {filepath}", level="error")
        except IOError as e:
            print_log(f"Error reading file '{filepath}': {e}", level="error")
    
    summary = {
        "summary": {
            "total_detections": total_detection_count,
            "total_files_scanned": total_files_scanned,
            "total_lines_scanned": total_lines_scanned
        }
    }
    detections.append(summary)

    try:
        with open(output_json_path, 'w', encoding='utf-8') as outfile:
            json.dump(detections, outfile, indent=2, ensure_ascii=False)
        print_log(f"Scan results saved to: {output_json_path}", level="success")
    except IOError as e:
        print_log(f"Error writing output file '{output_json_path}': {e}", level="error")
    
    print_log("Scanning completed.", level="success")

def main():
    parser = argparse.ArgumentParser(
        description="APK Fortify Scanner",
        formatter_class=argparse.RawTextHelpFormatter,
        epilog="""
Command Usage:
    python main.py --src file.apk --out output_directory --jadx_path /opt/jadx/bin/jadx --job_id my_scan_123
        """
    )
    parser.add_argument("--src", help="Source APK file path", required=True)
    parser.add_argument("--out", help="Output directory for scan results", required=True)
    parser.add_argument("--jadx_path", help="Path to the JADX decompiler executable. This MUST be an absolute path.", required=True)
    parser.add_argument("--job_id", help="Unique job ID for the scan. This will be used as the output JSON filename (e.g., my_scan_123.json).", required=True)

    args = parser.parse_args()

    apk_path = args.src
    output_dir = args.out
    jadx_path_arg = args.jadx_path
    job_id = args.job_id

    output_json_path = os.path.join(output_dir, f"{job_id}.json")

    print_log(f"Received parameters: APK='{apk_path}', Output Dir='{output_dir}', JADX Path='{jadx_path_arg}', Job ID='{job_id}'", level="info")

    if not os.path.exists(output_dir):
        print_log(f"Creating output directory: {output_dir}", level="info")
        try:
            os.makedirs(output_dir)
            print_log("Output directory created.", level="success")
        except OSError as e:
            print_log(f"Error creating output directory '{output_dir}': {e}", level="error")
            sys.exit(1)

    actual_jadx_path = check_jadx(jadx_path_arg)

    setup_decompilation(apk_path, actual_jadx_path)

    global patterns
    patterns.extend(load_patterns())

    files_to_scan = get_files_to_scan()
    
    if not files_to_scan:
        print_log(f"No files available for scanning. Job {job_id} will complete with no findings.", level="warning")
        if os.path.exists(SANDBOX_DIR):
            print_log(f"Cleaning up sandbox directory: {SANDBOX_DIR}", level="debug")
            try:
                shutil.rmtree(SANDBOX_DIR)
                print_log("Sandbox cleaned up.", level="info")
            except OSError as e:
                print_log(f"Error cleaning up sandbox directory '{SANDBOX_DIR}': {e}", level="error")
        sys.exit(0)

    scan_files(files_to_scan, output_json_path, patterns)

    print_log("Cleaning up sandbox directory.", level="info")
    if os.path.exists(SANDBOX_DIR):
        try:
            shutil.rmtree(SANDBOX_DIR)
            print_log("Sandbox cleaned up successfully.", level="success")
        except OSError as e:
            print_log(f"Error cleaning up sandbox directory '{SANDBOX_DIR}': {e}", level="error")
    else:
        print_log("Sandbox directory not found for cleanup.", level="debug")

    print_log(f"All tasks completed for job ID: {job_id}", level="success")

if __name__ == "__main__":
    main()