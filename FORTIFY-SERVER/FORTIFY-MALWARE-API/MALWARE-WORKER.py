
# ======================== IMPORTANT NOTICE ========================
#
#                       DO NOT ALTER THIS CODE.
#
# REASON: This script has been customized by the Team Lead to facilitate a
# system integration. Unauthorized modifications are guaranteed
# to cause project-wide failures.
#
# ACTION: Please implement any required functionality in other modules.
#
# ESCALATION: If a change to this file is unavoidable, you must first
# consult with the Team Lead.
#
# ================================================================


import argparse
import os
import shutil
import subprocess
import json
import re
import sys
from colorama import Fore, Style, init

init()

SANDBOX_DIR = "sandbox"
SOURCES_DIR = os.path.join(SANDBOX_DIR, "sources")
RESOURCES_DIR = os.path.join(SANDBOX_DIR, "resources")

SCAN_EXTENSIONS = ('.java', '.xml', '.smali')

EXCLUDE_PATH_COMPONENTS = {
    os.path.join('android'),
    os.path.join('androidx'),
    os.path.join('kotlin'),
    os.path.join('java'),
    os.path.join('javax'),
    os.path.join('org', 'json'),
    os.path.join('org', 'xmlpull'),
    os.path.join('junit'),
    os.path.join('android', 'support'),
    os.path.join('com', 'android', 'support'),
    os.path.join('com', 'google', 'android'),
    os.path.join('com', 'google', 'firebase'),
    os.path.join('com', 'google', 'ads'),
    os.path.join('com', 'google', 'gson'),
    os.path.join('com', 'google', 'zxing'),
    os.path.join('com', 'google', 'unity'),
    os.path.join('org', 'apache'),
    os.path.join('com', 'squareup'),
    os.path.join('com', 'bumptech'),
    os.path.join('com', 'facebook'),
    os.path.join('com', 'adjust'),
    os.path.join('com', 'appsflyer'),
    os.path.join('com', 'braze'),
    os.path.join('com', 'segment'),
    os.path.join('com', 'urbanairship'),
    os.path.join('com', 'onesignal'),
    os.path.join('com', 'razorpay'),
    os.path.join('com', 'stripe'),
    os.path.join('com', 'twilio'),
    os.path.join('io', 'branch', 'referral'),
    os.path.join('io', 'sentry'),
    os.path.join('io', 'reactivex'),
    os.path.join('com', 'fasterxml'),
    os.path.join('com', 'jakewharton'),
    os.path.join('com', 'crashlytics'),
    os.path.join('com', 'flurry'),
    os.path.join('com', 'mixpanel'),
    os.path.join('com', 'unity3d'),
    os.path.join('sandbox', 'resources', 'res', 'layout'),
    os.path.join('sandbox', 'resources', 'res', 'drawable'),
    os.path.join('sandbox', 'resources', 'res', 'anim'),
    os.path.join('sandbox', 'resources', 'res', 'menu'),
    os.path.join('sandbox', 'resources', 'res', 'xml'),
    os.path.join('sandbox', 'resources', 'res', 'raw'),
    os.path.join('sandbox', 'resources', 'res', 'color'),
    os.path.join('sandbox', 'resources', 'res', 'dimen'),
    os.path.join('sandbox', 'resources', 'res', 'font'),
    os.path.join('sandbox', 'resources', 'res', 'mipmap'),
    os.path.join('sandbox', 'resources', 'res', 'interpolator'),
    os.path.join('sandbox', 'resources', 'res', 'transition'),
}

patterns = []

def print_log(message, level="info"):
    """Prints a log message with minimal formatting and a tab indent."""
    prefix = "> ( ms ) ::"
    if level == "error":
        print(f"\t{Fore.RED}{prefix} {message}{Style.RESET_ALL}")
    else:
        print(f"\t{prefix} {message}")
    sys.stdout.flush()

def run_command(command, show_output=False, check_exit_code=True):
    """Executes a shell command and handles errors."""
    try:
        process = subprocess.run(
            command,
            capture_output=not show_output,
            text=True,
            check=check_exit_code,
            shell=isinstance(command, str)
        )
        return process.stdout.strip() if process.stdout else ""
    except subprocess.CalledProcessError as e:
        cmd_str = ' '.join(e.cmd) if isinstance(e.cmd, list) else e.cmd
        print_log(f"Command failed: {cmd_str}", level="error")
        if e.stderr:
            print_log(e.stderr.strip(), level="error")
        sys.exit(1)
    except Exception as e:
        print_log(f"An unexpected error occurred: {e}", level="error")
        sys.exit(1)

def check_jadx(jadx_path_arg):
    """Verifies that the JADX executable exists and is executable."""
    if not os.path.isabs(jadx_path_arg):
        print_log(f"JADX path must be absolute: '{jadx_path_arg}'", level="error")
        sys.exit(1)
    if not os.path.exists(jadx_path_arg):
        print_log(f"JADX executable not found at: '{jadx_path_arg}'", level="error")
        sys.exit(1)
    if not os.access(jadx_path_arg, os.X_OK):
        print_log(f"JADX is not executable: '{jadx_path_arg}'", level="error")
        sys.exit(1)
    return jadx_path_arg

def setup_decompilation(apk_path, jadx_exec_path):
    """Decompiles the given APK into the sandbox directory."""
    print_log("Started decompiling...")
    if os.path.exists(SANDBOX_DIR):
        shutil.rmtree(SANDBOX_DIR)
    os.makedirs(SANDBOX_DIR)
    
    decompile_command = [jadx_exec_path, "-d", SANDBOX_DIR, apk_path]
    run_command(decompile_command)
    print_log("Decompiling done.")

def get_files_to_scan():
    """Gathers a list of files to scan, respecting exclusion rules."""
    files_to_scan = []
    for scan_dir in [SOURCES_DIR, RESOURCES_DIR]:
        if not os.path.exists(scan_dir):
            continue
        for root, dirs, files in os.walk(scan_dir):
            # Efficiently prune excluded directories
            dirs[:] = [d for d in dirs if not any(ex in os.path.join(root, d) for ex in EXCLUDE_PATH_COMPONENTS)]
            for file in files:
                if file.lower().endswith(SCAN_EXTENSIONS):
                    filepath = os.path.join(root, file)
                    if not any(ex in filepath for ex in EXCLUDE_PATH_COMPONENTS):
                        files_to_scan.append(filepath)
    return files_to_scan

def load_patterns(pattern_file="patterns.txt"):
    """Loads regex patterns from the specified file."""
    if not os.path.exists(pattern_file):
        print_log(f"Pattern file not found: '{pattern_file}'", level="error")
        sys.exit(1)

    loaded_patterns = []
    with open(pattern_file, 'r', encoding='utf-8', errors='ignore') as f:
        for line in f:
            line = line.strip()
            if line and not line.startswith('#') and '::' in line:
                try:
                    regex_str, label = line.split('::', 1)
                    loaded_patterns.append((re.compile(regex_str.strip()), label.strip()))
                except re.error:
                    # Silently skip invalid regex to keep output clean
                    continue
    if not loaded_patterns:
        print_log("No valid patterns were loaded.", level="error")
        sys.exit(1)
    return loaded_patterns

def scan_files(files_to_scan, output_json_path, patterns):
    """Scans files for patterns and writes findings to a JSON file."""
    print_log(f"Started scan on {len(files_to_scan)} files...")
    detections = []
    for filepath in files_to_scan:
        try:
            with open(filepath, 'r', encoding='utf-8', errors='ignore') as infile:
                for line_num, line in enumerate(infile, 1):
                    for compiled_regex, label in patterns:
                        if compiled_regex.search(line):
                            detections.append({
                                "file": filepath,
                                "line": line_num,
                                "label": label,
                                "match": line.strip()
                            })
        except IOError:
            continue # Skip files that cannot be read

    summary = {
        "summary": {
            "total_detections": len(detections),
            "total_files_scanned": len(files_to_scan),
        }
    }
    
    output_data = {"summary": summary["summary"], "detections": detections}

    try:
        with open(output_json_path, 'w', encoding='utf-8') as outfile:
            json.dump(output_data, outfile, indent=2, ensure_ascii=False)
    except IOError as e:
        print_log(f"Failed to write results to '{output_json_path}': {e}", level="error")
    
    print_log("Scanning done.")

def main():
    parser = argparse.ArgumentParser(description="APK Fortify Scanner")
    parser.add_argument("--src", required=True, help="Source APK file path")
    parser.add_argument("--out", required=True, help="Output directory for scan results")
    parser.add_argument("--jadx_path", required=True, help="Absolute path to the JADX decompiler")
    parser.add_argument("--job_id", required=True, help="Unique job ID for the scan")
    args = parser.parse_args()

    print_log(f"Started job id: {args.job_id}")

    if not os.path.exists(args.out):
        os.makedirs(args.out)

    output_json_path = os.path.join(args.out, f"{args.job_id}.json")
    
    actual_jadx_path = check_jadx(args.jadx_path)
    setup_decompilation(args.src, actual_jadx_path)
    
    global patterns
    patterns.extend(load_patterns())
    
    files_to_scan = get_files_to_scan()
    
    if files_to_scan:
        scan_files(files_to_scan, output_json_path, patterns)
    else:
        print_log("No files found to scan.")

    # Cleanup
    if os.path.exists(SANDBOX_DIR):
        shutil.rmtree(SANDBOX_DIR)

    print_log(f"Completed job id: {args.job_id}. Results saved to: {output_json_path}")

if __name__ == "__main__":
    main()